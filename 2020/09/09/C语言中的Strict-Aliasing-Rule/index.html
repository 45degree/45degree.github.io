<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言中的Strict Aliasing Rule | QHome</title><meta name="author" content="degree45"><meta name="copyright" content="degree45"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="环境介绍 本文中使用的gcc和clang的版本分别为10.2.0和10.0.1, 操作系统为Archlinux 1234567891011&amp;gt; gcc --version&amp;gt; gcc (GCC) 10.2.0  Copyright © 2020 Free Software Foundatio"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://45degree.github.io/2020/09/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Strict-Aliasing-Rule/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="msvalidate.01" content="6D99B2952928E1E04B2176A1836EFC3C"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "cgdsnbi1wz");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言中的Strict Aliasing Rule',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-28 22:02:28'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/main/%E5%A4%B4%E5%83%8F1.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top_img/10.png')"><nav id="nav"><span id="blog-info"><a href="/" title="QHome"><span class="site-name">QHome</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言中的Strict Aliasing Rule</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-09T06:51:58.000Z" title="发表于 2020-09-09 14:51:58">2020-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-28T14:02:28.335Z" title="更新于 2024-04-28 22:02:28">2024-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86/">C 语言标准</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言中的Strict Aliasing Rule"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>环境介绍</h1>
<p>本文中使用的<code>gcc</code>和<code>clang</code>的版本分别为<code>10.2.0</code>和<code>10.0.1</code>, 操作系统为<code>Archlinux</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc --version</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc (GCC) 10.2.0</span></span><br><span class="line">  Copyright © 2020 Free Software Foundation, Inc.</span><br><span class="line">  本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；</span><br><span class="line">  包括没有适销性和某一专用目的下的适用性担保。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">clang --version</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">clang version 10.0.1</span> </span><br><span class="line">  Target: x86_64-pc-linux-gnu</span><br><span class="line">  Thread model: posix</span><br><span class="line">  InstalledDir: /usr/bin</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>本文用的标准是<code>c18</code>, 但是所用的内容在<code>c99</code>中也有同样的定义, 并不冲突。</p>
</div>
<h1>事件起因</h1>
<p>我在看<code>kernel</code>源代码中<code>READ_ONCE</code>宏的实现方法时，发现<code>READ_ONCE</code>宏的实现过程中定义了一个联合体，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __read_once_size(<span class="keyword">volatile</span> <span class="type">void</span> *p, <span class="type">void</span> *res, <span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: *(u8 *)res = *(<span class="keyword">volatile</span> u8 *)p; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: *(u16 *)res = *(<span class="keyword">volatile</span> u16 *)p; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: *(u32 *)res = *(<span class="keyword">volatile</span> u32 *)p; <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: *(u64 *)res = *(<span class="keyword">volatile</span> u64 *)p; <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ONCE(x)                                 \</span></span><br><span class="line"><span class="meta">(&#123;                                                   \</span></span><br><span class="line"><span class="meta">    union &#123; typeof(x) __val; char __c[1]; &#125; __u =    \</span></span><br><span class="line"><span class="meta">            &#123; .__c = &#123; 0 &#125; &#125;;                        \</span></span><br><span class="line"><span class="meta">    __read_once_size(&amp;(x), __u.__c, sizeof(x));      \</span></span><br><span class="line"><span class="meta">    __u.__val;                                       \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>该代码所在位置为<code>tools/include/linux/compiler.h</code>, 内核版本为<code>5.9-rc4</code>。而通过<a target="_blank" rel="noopener" href="https://lwn.net/Articles/624126/">lwm上的一篇文章</a>可以看出，在最开始的提交方案中<code>READ_ONCE</code>宏是按照如下方式实现的。</p>
<div class="note info flat"><p>内核主线仓库的commit记录中只能看到<code>READ_ONCE</code>宏的最终形式，邮件列表中的相关讨论内容由于年代太久远我已经找不到了。</p>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> READ_ONCE(p) \</span></span><br><span class="line"><span class="meta">    (&#123; typeof(p) __val; __read_once_size(&amp;p, &amp;__val, sizeof(__val)); __val; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>从之后的相关讨论中可以看出来，改成用联合体的方式的主要原因就在于之前的代码违背了<code>Strict Aliasing Rule</code>规则，造成了<code>undefined behavior</code></p>
<h1>Strict Aliasing Rule</h1>
<h2 id="Strict-Aliasing-Rule-是什么">Strict Aliasing Rule 是什么</h2>
<p>以下内容是gcc中对<code>Strict Aliasing Rule</code>的定义</p>
<blockquote>
<p>In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same.</p>
</blockquote>
<p>简单来说就是编译器认为一块内存地址不会存在两个不同的别名。当编译器采用“<code>-O2</code>”、“<code>-O3</code>”或“<code>-Os</code>”编译，并且不加“<code>-fno-strict-aliasing</code>”时，则编译器认为代码遵循<code>Strict Aliasing Rule</code>。</p>
<p>以下是一个简单的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">float</span>* f, <span class="type">int</span>* i)</span> &#123;</span><br><span class="line">    *i = <span class="number">1</span>;</span><br><span class="line">    *f = <span class="number">0.f</span>;</span><br><span class="line">    <span class="keyword">return</span> *i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数<code>foo</code>中存在两个指针，由于两个指针的类型不同，所以编译器在优化代码的时候会认为它们指向的是两块不同的内存。</p>
<h2 id="Strict-Aliasing-Rule-带来的问题">Strict Aliasing Rule 带来的问题</h2>
<p>考虑以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">float</span>* f, <span class="type">int</span>* i)</span> &#123;</span><br><span class="line">    *i = <span class="number">1</span>;</span><br><span class="line">    *f = <span class="number">0.f</span>;</span><br><span class="line">    <span class="keyword">return</span> *i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span>* p = (<span class="type">float</span>*)&amp;m;</span><br><span class="line">    <span class="type">int</span>* p2 = &amp;m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is %d\n&quot;</span>, m);</span><br><span class="line">    m = foo(p, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is %d\n&quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本我们希望该段代码的输出是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is 0</span><br><span class="line">is 0</span><br></pre></td></tr></table></figure>
<p>然而无论是用<code>gcc</code>还是<code>clang</code>编译(注意编译选项加入<code>-O2</code>), 最后的输出结果都是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc test.c -o <span class="built_in">test</span> -O2 -m32</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">is 0</span></span><br><span class="line">  is 1</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>如果你不加入优化选项，你得到的最后输出结果也确实是两个0</p>
</div>
<p>查看<code>gcc</code>生成的汇编代码中<code>foo</code>段的代码如下</p>
<div class="note info flat"><p>这里以32位汇编代码为例</p>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc -S test.c -o test.asm -O2 -m32 -masm=intel</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">.LFB11:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    mov eax, dword ptr 8[esp]</span><br><span class="line">    mov dword ptr [eax], 1</span><br><span class="line">    mov eax, dword ptr 4[esp]</span><br><span class="line">    mov dword ptr [eax], 0x00000000</span><br><span class="line">    mov eax, 1</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>
<p>编译器优化时采用的是<code>Type-Base Alias Analysis</code>(TBAA)方法, 认为<code>1</code>会被返回,并且<code>float</code>类型的指针不可能和<code>int</code>类型的指针指向同一个区域, 所以它直接将<code>1</code>移动到了<code>eax</code>寄存器作为返回值返回。</p>
<h2 id="c18标准文档的说明">c18标准文档的说明</h2>
<p>在c18标准文档的section 6.5的第7段中有如下描述</p>
<blockquote>
<p>An object shall have its stored value accessed only by an lvalue expression that has one of the following types:</p>
<ul>
<li>a type compatible with the effective type of the object</li>
<li>a qualified version of a type compatible with the effective type of the object</li>
<li>a type that is the signed or unsigned type corresponding to the effective type of the object</li>
<li>a type that is the signed or unsigned tyoe corresponding to a qualified version of the effective type of the object</li>
<li>an aggregate or union type that includes one of the aforementioned types among its members(including, recursively, a member of a subaggregate or contained union), or</li>
<li>a character type</li>
</ul>
</blockquote>
<p>在该段下方有一个脚注</p>
<blockquote>
<p>The intent of this list is to specify those circumstances in which an object can or cannot be aliased.</p>
</blockquote>
<p>按照c18文档的意思, 如果你想对一个对象起别名, 则在表达式中的左值必须满足以上6个条件中的一个(关于<code>compatible type</code>和<code>effective type</code>可以分别参考标准文档的section 6.2.7 和 section 6.5 的第6段, 也可以参考以下两个网页<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/object">effective type</a>、<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/type#Compatible_types">compatible type</a>)</p>
<p>关于这6个条件, 分别给出以下示例<sup><a href="#f1">1</a></sup></p>
<div>1. a type compatible with the effective type of the object</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x; <span class="comment">// *p gives us an lvalue expression of type int which is compatible with int</span></span><br></pre></td></tr></table></figure>
<div>2. a qualified version of a type compatible with the effective type of the object</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;x; <span class="comment">// *p gives us an lvalue expression of type const int which is compatible with int</span></span><br></pre></td></tr></table></figure>
<div>3. a type that is the signed or unsigned type corresponding to the effective type of the object</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="type">unsigned</span> <span class="type">int</span>*)&amp;x; <span class="comment">// *p gives us an lvalue expression of type unsigned int which corresponds to</span></span><br><span class="line">                                     <span class="comment">// the effective type of the object</span></span><br></pre></td></tr></table></figure>
<div>4. a type that is the signed or unsigned tyoe corresponding to a qualified version of the effective type of the object</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span>*)&amp;x; <span class="comment">// *p gives us an lvalue expression of type const unsigned int which is a unsigned type</span></span><br><span class="line">                                                 <span class="comment">// that corresponds with to a qualified version of the effective type of the object</span></span><br></pre></td></tr></table></figure>
<div>5. an aggregate or union type that includes one of the aforementioned types among its members(including, recursively, a member of a subaggregate or contained union)</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="keyword">struct</span> foo *fp, <span class="type">int</span>* ip)</span>; <span class="comment">// struct foo is an aggregate that includes int among its members</span></span><br><span class="line">                                      <span class="comment">// so it can alias with *ip;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>;</span></span><br><span class="line">foobar(&amp;foo, &amp;foo.x);</span><br></pre></td></tr></table></figure>
<div>6. a character type</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span>*)&amp;x; <span class="comment">// *p gives us an lvalue expression of type char which is a character type.</span></span><br><span class="line">                     <span class="comment">// The result are not portable due to endianness issues.</span></span><br></pre></td></tr></table></figure>
<h2 id="gcc-中对Strict-Aliasing-Rule的检测">gcc 中对Strict Aliasing Rule的检测</h2>
<p><code>gcc</code>提供了<code>-Wstrict-aliasing</code>选项来检测代码中可能存在违反<code>Strict Aliasing Rule</code>的地方<sup><a href="#f4">4</a></sup>。该选项共有3个级别(<code>level 1</code> ~ <code>level 3</code>), 默认是<code>level 3</code>, 其中<code>level 1</code>是检测最快，但错误率是最高的， 其次分别是<code>level 2</code>和<code>level 3</code>.</p>
<p>以下是在<code>level 2</code>下的检测结果, <code>level 3</code>没有报错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc test.c -o <span class="built_in">test</span> -O2 -Wstrict-aliasing=2</span></span><br><span class="line">  test.c: 在函数‘main’中:</span><br><span class="line">  test.c:13:24: 警告：提领类型双关的指针将破坏强重叠规则 [-Wstrict-aliasing]</span><br><span class="line">     13 |     float* p = (float*)&amp;m;</span><br><span class="line">        |                        ^~</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>更多关于<code>-Wstrict-aliasing</code>级别的信息可以查看<code>gcc</code>文档<sup><a href="#f4">4</a></sup></p>
<p><code>clang</code>当中也有<code>-Wstrict-aliasing</code>选项, 但是<code>clang</code>只是提供了接口, 并没有实现<sup><a href="#f5">5</a></sup>,所以这条编译选项不会起到任何作用。</p>
</div>
<div class="note warning flat"><p>总的来说<code>gcc</code>的这条编译选项还是太弱, 并不能检测到所有违反规则的地方</p>
</div>
<h2 id="如何避免Strict-Aliasing-Rule带来的优化问题">如何避免Strict Aliasing Rule带来的优化问题</h2>
<h3 id="使用-fno-strict-aliasing">使用<code>-fno-strict-aliasing</code></h3>
<p>这是最简单的方法，这条编译指令告诉编译器, 代码不遵守<code>Strict Aliasing Rule</code>, 不要做基于该规则的优化。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc test.c -o <span class="built_in">test</span> -O2 -fno-strict-aliasing</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./test</span></span><br><span class="line">  is 0</span><br><span class="line">  is 0</span><br></pre></td></tr></table></figure>
<h3 id="使用联合体">使用联合体</h3>
<p>以下是对<code>test.c</code>的一个改写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: test5.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test_union</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">float</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">union</span> test_union *f, <span class="type">int</span> *i)</span> &#123;</span><br><span class="line">    *i = <span class="number">1</span>;</span><br><span class="line">    f-&gt;p = <span class="number">0.f</span>;</span><br><span class="line">    <span class="keyword">return</span> *i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">test_union</span> <span class="title">m</span>;</span></span><br><span class="line">    m.n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p2 = &amp;m.n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is %d\n&quot;</span>, m.n);</span><br><span class="line">    m.n = foo(&amp;m, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is %d\n&quot;</span>, m.n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc test5.c -o test5 -O2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./test5</span></span><br><span class="line">  is 0</span><br><span class="line">  is 0</span><br></pre></td></tr></table></figure>
<p>能够这样做的原因在于文档中的第5条规则, 由于联合体内包含<code>int</code>类型，所以函数参数中<code>*i</code>可以是<code>*f</code>的别名(第一条规则)，因此不会做出优化。</p>
<div class="note info flat"><p><code>gcc</code>的文档中也给出了一个类似的例子<sup><a href="#f6">6</a></sup>，有兴趣可以去看一下，不赘述了。</p>
</div>
<h1>Strict Aliasing Rule与内存对齐</h1>
<h2 id="内存对齐带来的错误案例">内存对齐带来的错误案例</h2>
<p>在操作数组时, 与违背<code>Strict Aliasing Rule</code>同样经常犯的一个错误是内存对齐错误, 严重可能会引起<code>segmentation fault</code><sup><a href="#f2">2</a></sup>, 以下是一段示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test2.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">5</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0x0</span>, <span class="number">0xF</span>, <span class="number">0x0</span>, <span class="number">0xF</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)msg;</span><br><span class="line">    *p = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>这段代码用<code>gcc</code>和<code>clang</code>编译并不会产生<code>segmentation fault</code>, 但是并不能说这种行为就是合法的</p>
</div>
<p>毫无疑问这段代码违背了<code>Strict Aliasing Rule</code>, 但是这并不是最严重的问题, 老实说不会造成什么大影响。最严重的问题在于当把<code>char</code>类型的指针转换成<code>int</code>类型的指针可能发生<code>undefined behavior</code>。</p>
<h2 id="c18标准文档的关于对齐和指针的说明">c18标准文档的关于对齐和指针的说明</h2>
<p>在c18标准文档的section 6.3.2.3中, 有如下描述</p>
<blockquote>
<p>A pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined.</p>
</blockquote>
<p>同时在该段对应的脚注下有对<code>correctly aligned</code>做出额外说明</p>
<blockquote>
<p>In general, the concept “correctly aligned” is transitive: if a pointer to type A is correctly aligned for a pointer to type B, which in turn is correctly aligned for a pointer to type C , then a pointer to type A is correctly aligned for a pointer to type C .</p>
</blockquote>
<p>关于对齐, c18标准文档section 6.2.8 的第5段和第6段有如下说明</p>
<blockquote>
<p>Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.</p>
</blockquote>
<blockquote>
<p>The types char, signed char, and unsigned char shall have the weakest alignment requirement.</p>
</blockquote>
<p>所以按照标准, 如果<code>msg</code>是处在1字节或则2字节对齐的位置上, 将它转换成<code>int</code>类型的指针是<code>undefined behavior</code>(如果使用了<code>SIMD</code>, 后果可能很严重, 因为<code>SIMD</code>严格要求16字节对齐)</p>
<h2 id="gcc-和-clang-对于该行为的检查">gcc 和 clang 对于该行为的检查</h2>
<p><code>gcc</code> 和 <code>clang</code> 默认都提供了对该行为的检查, 在编译代码时通过<code>-fsanitize=alignment</code>或则<code>-fsanitize=undefined</code>即可开启</p>
<div class="note info flat"><p>该检查方法是在运行时检查。</p>
</div>
<p>以下是案例代码的编译和运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc -fsanitize=alignment test2.c -o test2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./test2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">test2.c:7:8: runtime error: store to misaligned address 0x7ffe5d2530c3 <span class="keyword">for</span> <span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>, <span class="built_in">which</span> requires 4 byte alignment</span></span><br><span class="line">  0x7ffe5d2530c3: note: pointer points here</span><br><span class="line">  00  c0 31 25 ff 00 0f 00 0f  00 3e 0d 79 ce f4 3d bb  e0 51 93 94 db 55 00 00  52 e1 02 cd b0 7f 00</span><br><span class="line">                ^</span><br><span class="line">  0x7ffe5d2530c3</span><br></pre></td></tr></table></figure>
<div class="note primary flat"><p>从报错信息来看, 出错的是段代码的第7行, 也及<code>*p = 0xFFFFFFFF</code>, 但是我个人感觉按照标准文档是第6行。 如果有错误希望能指出;</p>
</div>
<h2 id="如何避免内存对齐引起的错误">如何避免内存对齐引起的错误</h2>
<p>c18标准文档中提供了<code>_Alignas</code>和<code>_Alignof</code>来指定一个<code>object</code>的对齐方式, 具体方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test3.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">_Alignas</span>(<span class="keyword">_Alignof</span>(<span class="type">int</span>))<span class="type">char</span> msg[<span class="number">5</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0x0</span>, <span class="number">0xF</span>, <span class="number">0x0</span>, <span class="number">0xF</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)msg;</span><br><span class="line">    *p = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><p><code>_Alignas</code>和<code>_Alignof</code>也可以写成<code>alignas</code>和<code>alignof</code>, 后两个是前两个的宏定义，在<code>stdalign.h</code>可以找到</p>
</div>
<p>再次运行则不会发生错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc -fsanitize=alignment test3.c -o test3</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./test3</span></span><br><span class="line">  0x7ffe95014d00</span><br></pre></td></tr></table></figure>
<h1>c++的额外说明</h1>
<p><code>c++</code>中关于<code>Strict Aliasing Rule</code>和内存对齐的内容绝大多数是和<code>c</code>差不多的，但是在细节上和<code>c</code>有所出入,
详情可以查看<a href="#f1">参考文献1</a>和<code>c++17</code>草案。</p>
<h1>参考文献</h1>
<p><b id="f1">1.</b> <a target="_blank" rel="noopener" href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8">WhatIsStrictAliasingAndWhyDoWeCare</a>
<b id="f2">2.</b> <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46790550/c-undefined-behavior-strict-aliasing-rule-or-incorrect-alignment">c-undefined-behavior-strict-aliasing-rule-or-incorrect-alignment</a>
<b id="f3">3.</b> <a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#ubsan-checks">UndefinedBehaviorSanitizer</a>
<b id="f4">4.</b> <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wstrict-aliasing">https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wstrict-aliasing</a>
<b id="f5">5.</b> <a target="_blank" rel="noopener" href="https://github.com/llvm-mirror/clang/blob/master/test/Misc/warning-flags-tree.c">https://github.com/llvm-mirror/clang/blob/master/test/Misc/warning-flags-tree.c</a>
<b id="f6">6.</b> <a target="_blank" rel="noopener" href="https://gcc.gnu.org/bugs/#nonbugs">https://gcc.gnu.org/bugs/#nonbugs</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://45degree.github.io">degree45</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://45degree.github.io/2020/09/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Strict-Aliasing-Rule/">https://45degree.github.io/2020/09/09/C语言中的Strict-Aliasing-Rule/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://45degree.github.io" target="_blank">QHome</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Strict-Aliasing-Rule/">Strict Aliasing Rule</a><a class="post-meta__tags" href="/tags/C-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">C 内存对齐</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/c.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/main/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/main/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/img/main/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/main/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2020/10/06/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/" title="C语言中的位运算"><img class="cover" src="/img/cover/c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言中的位运算</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/main/%E5%A4%B4%E5%83%8F1.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">degree45</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/degree45"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/degree45" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1098902652@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">环境介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">事件起因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Strict Aliasing Rule</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Strict-Aliasing-Rule-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">Strict Aliasing Rule 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strict-Aliasing-Rule-%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">Strict Aliasing Rule 带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c18%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">c18标准文档的说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc-%E4%B8%AD%E5%AF%B9Strict-Aliasing-Rule%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.</span> <span class="toc-text">gcc 中对Strict Aliasing Rule的检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DStrict-Aliasing-Rule%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">如何避免Strict Aliasing Rule带来的优化问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-fno-strict-aliasing"><span class="toc-number">3.5.1.</span> <span class="toc-text">使用-fno-strict-aliasing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">3.5.2.</span> <span class="toc-text">使用联合体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Strict Aliasing Rule与内存对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">内存对齐带来的错误案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c18%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E7%9A%84%E5%85%B3%E4%BA%8E%E5%AF%B9%E9%BD%90%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">c18标准文档的关于对齐和指针的说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc-%E5%92%8C-clang-%E5%AF%B9%E4%BA%8E%E8%AF%A5%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">gcc 和 clang 对于该行为的检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%BC%95%E8%B5%B7%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">4.4.</span> <span class="toc-text">如何避免内存对齐引起的错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">c++的额外说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/SubdivNet%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="SubdivNet阅读笔记"><img src="/img/cover/mesh.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SubdivNet阅读笔记"/></a><div class="content"><a class="title" href="/2022/01/08/SubdivNet%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="SubdivNet阅读笔记">SubdivNet阅读笔记</a><time datetime="2022-01-08T06:56:38.000Z" title="发表于 2022-01-08 14:56:38">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/06/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/" title="C语言中的位运算"><img src="/img/cover/c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言中的位运算"/></a><div class="content"><a class="title" href="/2020/10/06/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/" title="C语言中的位运算">C语言中的位运算</a><time datetime="2020-10-06T09:41:26.000Z" title="发表于 2020-10-06 17:41:26">2020-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Strict-Aliasing-Rule/" title="C语言中的Strict Aliasing Rule"><img src="/img/cover/c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言中的Strict Aliasing Rule"/></a><div class="content"><a class="title" href="/2020/09/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84Strict-Aliasing-Rule/" title="C语言中的Strict Aliasing Rule">C语言中的Strict Aliasing Rule</a><time datetime="2020-09-09T06:51:58.000Z" title="发表于 2020-09-09 14:51:58">2020-09-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/top_img/10.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By degree45</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'dxKB1dW2aBqti9OidQQhwjVo-gzGzoHsz',
      appKey: 'lxYwzGLrbUp1XktVLAAQ14T2',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>